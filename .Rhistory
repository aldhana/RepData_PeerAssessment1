get <- function() x
## create a vector get to call the value
setinverse <- function(inverse) m <<- inverse
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
y <- makeCacheMatrix(x)
cacheSolve(x)
cacheSolve(y)
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve) m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
y <- makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverser is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
source('C:/Users/aldhana/Desktop/Data fluency/R/AssignmentWeek3/ProgrammingAssignment2/cachematrix.R')
y <- makeCacheMatrix(x)
cacheSolve(y)
y <- makeCacheMatrix(x)
source('C:/Users/aldhana/Desktop/Data fluency/R/AssignmentWeek3/ProgrammingAssignment2/cachematrix.R')
y <- makeCacheMatrix(x)
cacheSolve(y)
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve)m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve)m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x<-matrix(1:9, ncol=3, nrow=3)
x
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
cacheSolve(y)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse()
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve)m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x<-matrix(1:9, nrow=3, ncol = 3)
x
y
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve)m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x<-matrix(1:9, nrow = 3, ncol = 3)
x
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse()
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
View(cacheSolve)
makeCacheMatrix <- function(x = matrix()) {
## create a vector - makecachematrix to
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve)m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x<- matrix(1:9, nrow = 3, ncol = 3)
x
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse()
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
## create a variable m to assign the inverser of the matrix
set <- function(y) {
## create a two vectors in another environment
x <<- y
m <<- NULL
}
get <- function() x
## create a vector get to call the value
setinverse <- function(solve) m <<- solve
## create a vector 'setinverse' to get the inverse of the matrix
getinverse <- function() m
## get a vector with the inverser matrix and assign to m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x <- matrix(1:9, nrow = 3, ncol = 3)
x
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse()
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
x<-matrix(1:4, nrow = 2, ncol = 2)
x
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
## Create a vector Cachesolve to get the inverse function from the cache
## Return a matrix that is the inverse of 'x'from cache
m <- x$getinverse()
## assign the inverser matix to the varible m
if(!is.null(m)) {
## condition is to return true if arguement is false (checking to see if value of inverse is already computed)
message("getting cached data")
return(m)
## return computed values from cache
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(y)
cacheSolve(y)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x<- matrix(4:8, nrow = 2, ncol = 2)
x<- matrix(1:4, nrow = 2, ncol = 2)
x
x<- matrix(4:7, nrow = 2, ncol = 2)
x
y<-makeCacheMatix(x)
y<-makeCacheMatrix(x)
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(Y)
cacheSolve(x)
cacheSolve(y)
y
cacheSolve(y)
library(datasets)
data(iris)
?iris
iris
mean(iris[iris$Species == "virginica", ]$sepal.lenght)
mean(iris[iris$Species == "virginica", ]$sepal.Lenght)
x<- iris[iris$Species, ]
x
x<- iris[iris$Species, == "virginica"]
y<-mean(iris[iris$Species == "virginica", ]$sepal.Lenght)
y<-mean(iris[iris$Species == "virginica",]$Sepal.Lenght)
mean(iris[iris$Species == "virginica", ]$Sepal.Lenght)
?iris
iris
x<-iris
x
y<-x(x$Species="virginica")
y<-(x$Species=="virginica")
y
y<-(x$Species=="virginica"=TRUE)
y<-(x$Species=="virginica")
iris
x<-apply(iris, 2, mean)
x<-apply(iris)
iris
x<-iris
x
y<-subset(x,Species)
y<-(x$Species)
y
str(iris)
iris
colMeans(iris)
y<- colMeans(iris)
apply(iris[,4],2,mean)
iris
colMeans(iris)
apply(iris[, 1:4],2,mean)
y<-(x$Species=="virginica")
x<-iris
x
y<-subset(x$Species=="virginica")
library(swirl)
swirl()
C(44, NA, 5, NA)
x>- c(44, NA, 5, NA)
x <- c(44, NA, 5,NA)
x*3
y <- rnorm(1000)
y
z <- rep(NA, 1000)
my_data <- sample(c(y, z), 100)
my_na <- is.na(my_data)
my_na
my_data == NA
sum(my_na, na.rm = TRUE)
sum(my_na  )
my_data
0/0
Inf-Ind
Inf-Inf
x
x[1:10]
x[is.na(x)]
y <- x[!is.na(x)]
y
y[y > 0]
x[x>0]
x[!is.na(x & x > 0)]
x[!is.na(x) & x > 0)]
x[!is.na(x) & x > 0)]
x[!is.na(x) & x > 0)
x[!is.na(x) & x > 0)]
x[!is.na(x) & x > 0]
c(x, 3:7)
c(3, 5, 7)
[c(3, 5, 7)]
[c(3, 5, 7)]
c(3, 5, 7)
[c(3, 5, 7)]
gg
[c]
[c(3, 5, 7)]
c(3, 5, 7)
a <-[c(3, 5, 7)]
a
c(3, 5, 7)
c(3, 5, 7)[]
x <- c(3, 5, 7)
[c(3, 5, 7)]
[c(3, 5, 7),]
c(3, 5, 7),
[c(3, 5, 7),]
[c(3, 5, 7)]
c
[c(3, 5, 7)]
[c(3, 5, 7)]
bye
bye
info()
bye()
swirl()
x[c(3, 5, 7)]
x[0]
x[3000]
x[c(-2, -10)]
x[-c92,10]
x[-c(9)2,10]
x[-c(2,10)]
vect <- c(foo = 11, bar = 2, norf = NA)
vect
names(vect)
vect2 <- c(11, 2, NA)
vect2 <- c("foo", "bar", "norf")
names(vect2) <- c("foo", "bar", "norf")
vect()
identical(vect)
identical (vect)
identical (vect, vect2)
vect["bar"]
vect[c("foo", "bar")]
set.seed(1)
rpois(5, 2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
y
View(x)
View(x)
View(x)
View(x)
View(x)
library(datasets)
library()
library(datasets)
data(cars)
with(cars, plot(speed, dist))
library(lattice)
state <- data.frame(state.x77, region == state.region)
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
data(mpg)
qplot(displ,hwy, data = mpg)
setwd("C:/Users/aldhana/Desktop/Data fluency/Reproducible reserach/Assignment")
data <- read.table("activity.csv", header = TRUE)
data <- read.csv("activity.csv", header = TRUE)
data <- read.csv("activity.csv", colClasses = c("integer", "Date", "factor"))
colnames(data)
noNA <- na.omit(data)
noNA <- na.omit(data)
summary(noNA)
rownames(noNA) <- 1:nrow(noNA)
da
rownames(noNA) <- 1:nrow(noNA)
rownames(noNA) <- 1:nrow(noNA)
summary(noNA)
summary(rownames(noNA))
head(noNA)
dim(noNA)
attach(noNA)
noNA$month <- as.numeric(format(date, "%m"))
head(noNA)
dim(noNA)
attach(noNA)
noNA$month <- as.numeric(format(date, "%m"))
library(ggplot2)
ggplot(noNA, aes(date, steps)) + geom_bar(stat = "identity", colour = "steelblue", fill = "steelblue", width = 0.7) + facet_grid(. ~ month, scales = "free") + labs(title = "Histogram of Total Number of Steps Taken Each Day", x = "Date", y = "Total number of steps")
totalSteps <- aggregate(steps, list(Date = date), FUN = "sum")$x
mean(totalSteps)
median(totalSteps)
median(totalSteps)
ggplot(avgSteps, aes(interval, y = x)) + geom_line() + labs(title = "Time Series Plot of the 5-minute Interval", x = "5-minute intervals", y = "Average Number of Steps Taken")
avgSteps <- aggregate(steps, list(interval = as.numeric(as.character(interval))), FUN = "mean")
ggplot(avgSteps, aes(interval, y = x)) + geom_line() + labs(title = "Time Series Plot of the 5-minute Interval", x = "5-minute intervals", y = "Average Number of Steps Taken")
attach(avgSteps)
avgSteps[x == max(x), ]
sum(is.na(data))
library(nlme)
library(lattice)
xyplot(weight ~ Time | Diet, BodyWeight)
print(g)
